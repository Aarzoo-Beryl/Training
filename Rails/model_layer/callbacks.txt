CALLBACKS---------------


LIFE CYCLE OF ACTIVE RECORD OBJECT - 
          - refers to sequence of states and transitions that the object undergoes from the moment it is instantiated until its destroyed
          - lifecycle stages - 
                    - instantiated
                    - validation
                    - saving 
                    - updating
                    - destroying

CALLBACKS - refers to feature of ruby on rails that allow you to trigger methods at specific points in an object's lifecycle
          - useful for executing code when certain events occur to a model 
          - helps to add triggers related to lifecycle of your model in a clean and organized manner
    
    - registration - to effectively use callbacks , the callback need to be registered first within you models
                   - can be registered in various ways , each method provide a different approach in organizing your code
                   - can also be registered to fire only at certain lifecycle events, allowing complete control over when and in what context your callbacks are triggered 
                   - these certain lifecycle events are specified using "on:" after the callback methods
                   - example - before_validation :name.empty? , on: :create
                        or   - before_validation :name.empty? , on: [:create, :update]
          
          - MACRO-STYLE class method - 
                   - this refers to defining callbacks as methods on the model
                   - and then register them using macro_style class methods/ call type (like before_create)

          - INLINE blocks - 
                   - if the block is short , you can directly write it in a block 

          - PROCS - 
                   - proc can be used to encapsulate the callback logic

          - CUSTOM - 
                   - separate class can be defined for callback for more complex logic
                   
    problematic approach - 
          1. calling update/save directly inside a callback can trigger the same callback infinitely
          2. also if a callback fails and transaction is rolled back; changes made by update/save might persist
          eg -  class Person < ApplicationRecord
                  validates :name, :age, presence: true

                  before_validation :check_age

                  def check_age
                    update(age: 18)
                  end
                end
    safe approach - 
          1. instead you should assign values to the models attributes directly within 'before_create' or 'before_update' 
          2.this way changes will be picked up when the model is eventually saved, without causing any side effects
          eg -  class User < Person
                  validates :name, :age, presence: true

                  before_validation :check_age

                  def check_age
                    update(age: 18)
                  end
                end 
          # this first checks the value of self.status
          # if it already has a value , does nothing
          # if value == nil/false, it assigns it as 18.

TYPES OF CALLBACKS - 
    (in order of execution)

    - CREATING AN OBJECT - 
          - before_validation - triggered before the specified validations of the module are performed
                    eg -  class Customer < ApplicationRecord
                            has_many :addresses,  validate: true
                            has_many :review, inverse_of: :customer, validate: true
                            has_many :orders
                            has_many :payments, through: :bill

                            validates :name, presence: true
                            validates :phone_number, presence: true
                            validates :email, presence: true, uniqueness: true

                            before_validation :check_name, on: [:create, :update]

                            private
                              def check_name
                                if name.blank?
                                  puts "name is blank"
                                end
                              end
                          end
                    practice - 3.3.1 :003 > b = Customer.new
                                => #<Customer:0x00007f80178ad5d8 id: nil, name: nil, phone_number: nil, email: nil, created_at: nil, updated_at: nil> 
                                3.3.1 :004 > b.valid?
                                name is blank
                                  Customer Exists? (0.5ms)  SELECT 1 AS one FROM "customers" WHERE "customers"."email" IS NULL LIMIT $1  [["LIMIT", 1]]
                                ensure your phone number is  
                                => false 


          - after_validation - triggered after the specified validations of the module are performed
                    eg -  class Seller < ApplicationRecord
                            has_many :products, dependent: :destroy

                            validates :name, presence: true, format: {with: /\A[a-zA-z]}
                            validates :phone_number, presence: true
                            validates :email, presence: true, uniqueness: true

                            after_validation :log_errors

                            private
                              def log_errors
                                if errors.any?
                                  puts("validation was unsuccessful because:#{errors.full_messages.join(',')}")
                                end
                              end

                          end

                    practice -  3.3.1 :023 > s.name= "harish"
                                => "harish" 
                                3.3.1 :024 > s.valid?
                                  Seller Exists? (0.6ms)  SELECT 1 AS one FROM "sellers" WHERE "sellers"."email" IS NULL LIMIT $1  [["LIMIT", 1]]
                                validation was unsuccessful because:Phone number can't be blank,Email can't be blank
                                => false 
 

          - before_save - triggered before the object is save in the database
                    eg -  class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                          end


          - around_save - triggered when the object is being save in the database
                    eg -  class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price
                            around_save :log_activity

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                              def log_activity
                                puts("around save : before save")
                                yield
                                puts("around save : after save")
                              end
                          end
                    practice -  3.3.1 :006 > p = Product.new( id: 4,name: "Mouse",description: "Computer accessory",price: 2000,brand_id: 1,seller_id: 1,category_id: 1)
                                => 
                                #<Product:0x00007fdbc4c7ecd0
                                ... 
                                3.3.1 :007 > p.save
                                  TRANSACTION (0.3ms)  BEGIN
                                  Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Seller Load (0.3ms)  SELECT "sellers".* FROM "sellers" WHERE "sellers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                as the price of the product was not mentioned it was taken as zero by default
                                around save : before save
                                  Product Create (1.0ms)  INSERT INTO "products" ("id", "name", "description", "price", "created_at", "updated_at", "brand_id", "seller_id", "category_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["id", 4], ["name", "Mouse"], ["description", "Computer accessory"], ["price", 2000], ["created_at", "2024-07-03 06:12:13.318960"], ["updated_at", "2024-07-03 06:12:13.318960"], ["brand_id", 1], ["seller_id", 1], ["category_id", 1]]
                                around save : after save
                                the object was successfully saved
                                  Category Update (0.4ms)  UPDATE "categories" SET "updated_at" = $1 WHERE "categories"."id" = $2  [["updated_at", "2024-07-03 06:12:13.322275"], ["id", 1]]
                                  TRANSACTION (3.2ms)  COMMIT
                                => true 

          - before_create - triggered before the object is created in the database
                    eg - 
          - around_create - triggered when the object is being created in the database
                    eg - 
          - after_create - triggered after the object is created in the database
                    eg - 
          - after_save - triggered after the object is save in the database
                    eg - class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price
                            around_save :log_activity
                            after_save :clear_cache

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                              def log_activity
                                puts("around save : before save")
                                yield
                                puts("around save : after save")
                              end
                              def clear_cache
                                CacheService.clear_product_cache(self)
                              end
                          end
                    practice -  3.3.1 :006 > p = Product.new( id: 4,name: "Mouse",description: "Computer accessory",price: 2000,brand_id: 1,seller_id: 1,category_id: 1)
                                => 
                                #<Product:0x00007fdbc4c7ecd0
                                ... 
                                3.3.1 :007 > p.save
                                  TRANSACTION (0.3ms)  BEGIN
                                  Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Seller Load (0.3ms)  SELECT "sellers".* FROM "sellers" WHERE "sellers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                as the price of the product was not mentioned it was taken as zero by default
                                around save : before save
                                  Product Create (1.0ms)  INSERT INTO "products" ("id", "name", "description", "price", "created_at", "updated_at", "brand_id", "seller_id", "category_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["id", 4], ["name", "Mouse"], ["description", "Computer accessory"], ["price", 2000], ["created_at", "2024-07-03 06:12:13.318960"], ["updated_at", "2024-07-03 06:12:13.318960"], ["brand_id", 1], ["seller_id", 1], ["category_id", 1]]
                                around save : after save
                                the object was successfully saved
                                  Category Update (0.4ms)  UPDATE "categories" SET "updated_at" = $1 WHERE "categories"."id" = $2  [["updated_at", "2024-07-03 06:12:13.322275"], ["id", 1]]
                                  TRANSACTION (3.2ms)  COMMIT
                                => true 
          - after_commit/after_rollback - triggered if the transaction is completed/rollback
                    eg - 

    - UPDATING AN OBJECT - 
          - before_validation - triggered before the specified validations of the module are performed
                    eg -  class Customer < ApplicationRecord
                            has_many :addresses,  validate: true
                            has_many :review, inverse_of: :customer, validate: true
                            has_many :orders
                            has_many :payments, through: :bill

                            validates :name, presence: true
                            validates :phone_number, presence: true
                            validates :email, presence: true, uniqueness: true

                            before_validation :check_name, on: [:create, :update]

                            private
                              def check_name
                                if name.blank?
                                  puts "name is blank"
                                end
                              end
                          end

          - after_validation - triggered after the specified validations of the module are performed
                    eg -  class Customer < ApplicationRecord
                            has_many :addresses,  validate: true
                            has_many :review, inverse_of: :customer, validate: true
                            has_many :orders
                            has_many :payments, through: :bill

                            validates :name, presence: true
                            validates :phone_number, presence: true
                            validates :email, presence: true, uniqueness: true

                            before_validation :check_name, on: [:create, :update]

                            after_validation :check_phone_number

                            private
                              def check_name
                                if name.blank?
                                  puts "name is blank"
                                end
                              end

                              def check_phone_number
                                @a = self.phone_number
                                puts "ensure your phone number is #{@a} "
                              end
                          end
          - before_save - triggered before the object is save in the database
                    eg - class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                          end

          - around_save - triggered when the object is being save in the database
                    eg -  class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price
                            around_save :log_activity

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                              def log_activity
                                puts("around save : before save")
                                yield
                                puts("around save : after save")
                              end
                          end
                    practice -  3.3.1 :006 > p = Product.new( id: 4,name: "Mouse",description: "Computer accessory",price: 2000,brand_id: 1,seller_id: 1,category_id: 1)
                                => 
                                #<Product:0x00007fdbc4c7ecd0
                                ... 
                                3.3.1 :007 > p.save
                                  TRANSACTION (0.3ms)  BEGIN
                                  Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Seller Load (0.3ms)  SELECT "sellers".* FROM "sellers" WHERE "sellers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                as the price of the product was not mentioned it was taken as zero by default
                                around save : before save
                                  Product Create (1.0ms)  INSERT INTO "products" ("id", "name", "description", "price", "created_at", "updated_at", "brand_id", "seller_id", "category_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["id", 4], ["name", "Mouse"], ["description", "Computer accessory"], ["price", 2000], ["created_at", "2024-07-03 06:12:13.318960"], ["updated_at", "2024-07-03 06:12:13.318960"], ["brand_id", 1], ["seller_id", 1], ["category_id", 1]]
                                around save : after save
                                the object was successfully saved
                                  Category Update (0.4ms)  UPDATE "categories" SET "updated_at" = $1 WHERE "categories"."id" = $2  [["updated_at", "2024-07-03 06:12:13.322275"], ["id", 1]]
                                  TRANSACTION (3.2ms)  COMMIT
                                => true 
          - before_update - triggered before the object is created in the database
                    eg - 
          - around_update - triggered when the object is being created in the database
                    eg - 
          - after_update - triggered after the object is created in the database
                    eg - 
          - after_save -  triggered after the object is save in the database
                    eg -  class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price
                            around_save :log_activity
                            after_save :clear_cache

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                              def log_activity
                                puts("around save : before save")
                                yield
                                puts("around save : after save")
                              end
                              def clear_cache
                                CacheService.clear_product_cache(self)
                              end
                          end
                    practice -  3.3.1 :006 > p = Product.new( id: 4,name: "Mouse",description: "Computer accessory",price: 2000,brand_id: 1,seller_id: 1,category_id: 1)
                                => 
                                #<Product:0x00007fdbc4c7ecd0
                                ... 
                                3.3.1 :007 > p.save
                                  TRANSACTION (0.3ms)  BEGIN
                                  Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Seller Load (0.3ms)  SELECT "sellers".* FROM "sellers" WHERE "sellers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                as the price of the product was not mentioned it was taken as zero by default
                                around save : before save
                                  Product Create (1.0ms)  INSERT INTO "products" ("id", "name", "description", "price", "created_at", "updated_at", "brand_id", "seller_id", "category_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["id", 4], ["name", "Mouse"], ["description", "Computer accessory"], ["price", 2000], ["created_at", "2024-07-03 06:12:13.318960"], ["updated_at", "2024-07-03 06:12:13.318960"], ["brand_id", 1], ["seller_id", 1], ["category_id", 1]]
                                around save : after save
                                the object was successfully saved
                                  Category Update (0.4ms)  UPDATE "categories" SET "updated_at" = $1 WHERE "categories"."id" = $2  [["updated_at", "2024-07-03 06:12:13.322275"], ["id", 1]]
                                  TRANSACTION (3.2ms)  COMMIT
                                => true 
          - after_commit/after_rollback - triggered if the transaction is completed/rollback
                    eg - 

    - DESTROYING AN OBJECT - 
          - before_destroy - triggered before the object is created in the database
                    eg - 
          - around_destroy - triggered when the object is being created in the database
                    eg - 
          - after_destroy - triggered after the object is created in the database
                    eg - 
          - after_commit/after_rollback - triggered if the transaction is completed/rollback
                    eg - 

    Note - 
          1. if exception occurs in an after_save, transaction will be rolled back and the data will not be persisted in the database
          2. execution of after_commit ensures that the transaction has already completed and data has persisted to database