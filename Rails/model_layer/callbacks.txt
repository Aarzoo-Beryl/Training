CALLBACKS---------------


LIFE CYCLE OF ACTIVE RECORD OBJECT - 
          - refers to sequence of states and transitions that the object undergoes from the moment it is instantiated until its destroyed
          - lifecycle stages - 
                    - instantiated
                    - validation
                    - saving 
                    - updating
                    - destroying

CALLBACKS - refers to feature of ruby on rails that allow you to trigger methods at specific points in an object's lifecycle
          - useful for executing code when certain events occur to a model 
          - helps to add triggers related to lifecycle of your model in a clean and organized manner
    
    - registration - to effectively use callbacks , the callback need to be registered first within you models
                   - can be registered in various ways , each method provide a different approach in organizing your code
                   - can also be registered to fire only at certain lifecycle events, allowing complete control over when and in what context your callbacks are triggered 
                   - these certain lifecycle events are specified using "on:" after the callback methods
                   - example - before_validation :name.empty? , on: :create
                        or   - before_validation :name.empty? , on: [:create, :update]
          
          - MACRO-STYLE class method - 
                   - this refers to defining callbacks as methods on the model
                   - and then register them using macro_style class methods/ call type (like before_create)

          - INLINE blocks - 
                   - if the block is short , you can directly write it in a block 

          - PROCS - 
                   - proc can be used to encapsulate the callback logic

          - CUSTOM - 
                   - separate class can be defined for callback for more complex logic
                   
    problematic approach - 
          1. calling update/save directly inside a callback can trigger the same callback infinitely
          2. also if a callback fails and transaction is rolled back; changes made by update/save might persist
          eg -  class Person < ApplicationRecord
                  validates :name, :age, presence: true

                  before_validation :check_age

                  def check_age
                    update(age: 18)
                  end
                end
    safe approach - 
          1. instead you should assign values to the models attributes directly within 'before_create' or 'before_update' 
          2.this way changes will be picked up when the model is eventually saved, without causing any side effects
          eg -  class User < Person
                  validates :name, :age, presence: true

                  before_validation :check_age

                  def check_age
                    update(age: 18)
                  end
                end 
          # this first checks the value of self.status
          # if it already has a value , does nothing
          # if value == nil/false, it assigns it as 18.

TYPES OF CALLBACKS - 
    (in order of execution)

    - CREATING AN OBJECT - 
          - before_validation - triggered before the specified validations of the module are performed
                    eg -  class Customer < ApplicationRecord
                            has_many :addresses,  validate: true
                            has_many :review, inverse_of: :customer, validate: true
                            has_many :orders
                            has_many :payments, through: :bill

                            validates :name, presence: true
                            validates :phone_number, presence: true
                            validates :email, presence: true, uniqueness: true

                            before_validation :check_name, on: [:create, :update]

                            private
                              def check_name
                                if name.blank?
                                  puts "name is blank"
                                end
                              end
                          end
                    practice - 3.3.1 :003 > b = Customer.new
                                => #<Customer:0x00007f80178ad5d8 id: nil, name: nil, phone_number: nil, email: nil, created_at: nil, updated_at: nil> 
                                3.3.1 :004 > b.valid?
                                name is blank
                                  Customer Exists? (0.5ms)  SELECT 1 AS one FROM "customers" WHERE "customers"."email" IS NULL LIMIT $1  [["LIMIT", 1]]
                                ensure your phone number is  
                                => false 


          - after_validation - triggered after the specified validations of the module are performed
                    eg -  class Seller < ApplicationRecord
                            has_many :products, dependent: :destroy

                            validates :name, presence: true, format: {with: /\A[a-zA-z]}
                            validates :phone_number, presence: true
                            validates :email, presence: true, uniqueness: true

                            after_validation :log_errors

                            private
                              def log_errors
                                if errors.any?
                                  puts("validation was unsuccessful because:#{errors.full_messages.join(',')}")
                                end
                              end

                          end

                    practice -  3.3.1 :023 > s.name= "harish"
                                => "harish" 
                                3.3.1 :024 > s.valid?
                                  Seller Exists? (0.6ms)  SELECT 1 AS one FROM "sellers" WHERE "sellers"."email" IS NULL LIMIT $1  [["LIMIT", 1]]
                                validation was unsuccessful because:Phone number can't be blank,Email can't be blank
                                => false 
 

          - before_save - triggered before the object is save in the database
                    eg -  class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                          end


          - around_save - triggered when the object is being save in the database
                    eg -  class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price
                            around_save :log_activity

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                              def log_activity
                                puts("around save : before save")
                                yield
                                puts("around save : after save")
                              end
                          end
                    practice -  3.3.1 :006 > p = Product.new( id: 4,name: "Mouse",description: "Computer accessory",price: 2000,brand_id: 1,seller_id: 1,category_id: 1)
                                => 
                                #<Product:0x00007fdbc4c7ecd0
                                ... 
                                3.3.1 :007 > p.save
                                  TRANSACTION (0.3ms)  BEGIN
                                  Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Seller Load (0.3ms)  SELECT "sellers".* FROM "sellers" WHERE "sellers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                as the price of the product was not mentioned it was taken as zero by default
                                around save : before save
                                  Product Create (1.0ms)  INSERT INTO "products" ("id", "name", "description", "price", "created_at", "updated_at", "brand_id", "seller_id", "category_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["id", 4], ["name", "Mouse"], ["description", "Computer accessory"], ["price", 2000], ["created_at", "2024-07-03 06:12:13.318960"], ["updated_at", "2024-07-03 06:12:13.318960"], ["brand_id", 1], ["seller_id", 1], ["category_id", 1]]
                                around save : after save
                                the object was successfully saved
                                  Category Update (0.4ms)  UPDATE "categories" SET "updated_at" = $1 WHERE "categories"."id" = $2  [["updated_at", "2024-07-03 06:12:13.322275"], ["id", 1]]
                                  TRANSACTION (3.2ms)  COMMIT
                                => true 

          - before_create - triggered before the object is created in the database
                    eg -  class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            before_create :capitalize_title

                            private
                              def capitalize_title
                                title.capitalize! if title.present?
                              end
                          end
                    practice -  3.3.1 :006 > p = PaymentType.create(title: "paypal",description:"used for international payments mostly")
                                  TRANSACTION (0.2ms)  BEGIN
                                  PaymentType Create (0.9ms)  INSERT INTO "payment_types" ("title", "description", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["title", "Paypal"], ["description", "used for international payments mostly"], ["created_at", "2024-07-03 06:30:08.823577"], ["updated_at", "2024-07-03 06:30:08.823577"]]
                                  TRANSACTION (1.5ms)  COMMIT
                                => 
                                #<PaymentType:0x00007ff09a086870
                                ... 
                                3.3.1 :007 > p.title
                                => "Paypal" 

          - around_create - triggered when the object is being created in the database
                    eg -  class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            before_create :capitalize_title
                            around_create :lifecycle_info
                            after_create :confirmation_info
                            private
                              def capitalize_title
                                title.capitalize! if title.present?
                              end
                              def lifecycle_info
                                  puts("around create : before create")
                                  yield
                                  puts("around create : after create")
                              end
                              def confirmation_info
                                puts("Payment type was successfully created")
                              end
                          end
                    practice -  3.3.1 :011 > p = PaymentType.create(title: "cash on delivery",description:"physical payment method")
                                around create : before create
                                  TRANSACTION (0.2ms)  BEGIN
                                  PaymentType Create (1.0ms)  INSERT INTO "payment_types" ("title", "description", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["title", "Cash on delivery"], ["description", "physical payment method"], ["created_at", "2024-07-03 06:36:05.926327"], ["updated_at", "2024-07-03 06:36:05.926327"]]
                                around create : after create
                                Payment type was successfully created
                                  TRANSACTION (1.1ms)  COMMIT
                                => 
                                #<PaymentType:0x00007ff099ce8560


          - after_create - triggered after the object is created in the database
                    eg -  class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            before_create :capitalize_title
                            around_create :lifecycle_info
                            after_create :confirmation_info
                            private
                              def capitalize_title
                                title.capitalize! if title.present?
                              end
                              def lifecycle_info
                                  puts("around create : before create")
                                  yield
                                  puts("around create : after create")
                              end
                              def confirmation_info
                                puts("Payment type was successfully created")
                              end
                          end
                    practice -  3.3.1 :011 > p = PaymentType.create(title: "cash on delivery",description:"physical payment method")
                                around create : before create
                                  TRANSACTION (0.2ms)  BEGIN
                                  PaymentType Create (1.0ms)  INSERT INTO "payment_types" ("title", "description", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["title", "Cash on delivery"], ["description", "physical payment method"], ["created_at", "2024-07-03 06:36:05.926327"], ["updated_at", "2024-07-03 06:36:05.926327"]]
                                around create : after create
                                Payment type was successfully created
                                  TRANSACTION (1.1ms)  COMMIT
                                => 
                                #<PaymentType:0x00007ff099ce8560

          - after_save - triggered after the object is save in the database
                    eg - class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price
                            around_save :log_activity
                            after_save :clear_cache

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                              def log_activity
                                puts("around save : before save")
                                yield
                                puts("around save : after save")
                              end
                              def clear_cache
                                CacheService.clear_product_cache(self)
                              end
                          end
                    practice -  3.3.1 :006 > p = Product.new( id: 4,name: "Mouse",description: "Computer accessory",price: 2000,brand_id: 1,seller_id: 1,category_id: 1)
                                => 
                                #<Product:0x00007fdbc4c7ecd0
                                ... 
                                3.3.1 :007 > p.save
                                  TRANSACTION (0.3ms)  BEGIN
                                  Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Seller Load (0.3ms)  SELECT "sellers".* FROM "sellers" WHERE "sellers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                as the price of the product was not mentioned it was taken as zero by default
                                around save : before save
                                  Product Create (1.0ms)  INSERT INTO "products" ("id", "name", "description", "price", "created_at", "updated_at", "brand_id", "seller_id", "category_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["id", 4], ["name", "Mouse"], ["description", "Computer accessory"], ["price", 2000], ["created_at", "2024-07-03 06:12:13.318960"], ["updated_at", "2024-07-03 06:12:13.318960"], ["brand_id", 1], ["seller_id", 1], ["category_id", 1]]
                                around save : after save
                                the object was successfully saved
                                  Category Update (0.4ms)  UPDATE "categories" SET "updated_at" = $1 WHERE "categories"."id" = $2  [["updated_at", "2024-07-03 06:12:13.322275"], ["id", 1]]
                                  TRANSACTION (3.2ms)  COMMIT
                                => true 
          - after_commit/after_rollback - triggered if the transaction is completed/rollback
                    eg -  class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            after_commit :commit_info
                            after_rollback :rollback_info

                            private
                              
                              def commit_info
                                puts("The transaction was successfully committed for PaymentType #{self.title}")
                              end
                              def rollback_info
                                puts("The transaction was rolled back because of : #{self.error.full_messages.join(',')}")
                              end
                          end
                    practice -  3.3.1 :016 > a = PaymentType.create(title:"EMI", description:"methodtopay in installments")
                                around create : before create
                                  TRANSACTION (0.2ms)  BEGIN
                                  PaymentType Create (1.1ms)  INSERT INTO "payment_types" ("title", "description", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["title", "Emi"], ["description", "methodtopay in installments"], ["created_at", "2024-07-03 06:45:31.682087"], ["updated_at", "2024-07-03 06:45:31.682087"]]
                                around create : after create
                                Payment type was successfully created
                                  TRANSACTION (1.9ms)  COMMIT
                                The transaction was successfully committed for PaymentType Emi
                                => 
                                #<PaymentType:0x00007ff09a08eac0


    - UPDATING AN OBJECT - 
          - before_validation - triggered before the specified validations of the module are performed
                    eg -  class Customer < ApplicationRecord
                            has_many :addresses,  validate: true
                            has_many :review, inverse_of: :customer, validate: true
                            has_many :orders
                            has_many :payments, through: :bill

                            validates :name, presence: true
                            validates :phone_number, presence: true
                            validates :email, presence: true, uniqueness: true

                            before_validation :check_name, on: [:create, :update]

                            private
                              def check_name
                                if name.blank?
                                  puts "name is blank"
                                end
                              end
                          end

          - after_validation - triggered after the specified validations of the module are performed
                    eg -  class Customer < ApplicationRecord
                            has_many :addresses,  validate: true
                            has_many :review, inverse_of: :customer, validate: true
                            has_many :orders
                            has_many :payments, through: :bill

                            validates :name, presence: true
                            validates :phone_number, presence: true
                            validates :email, presence: true, uniqueness: true

                            before_validation :check_name, on: [:create, :update]

                            after_validation :check_phone_number

                            private
                              def check_name
                                if name.blank?
                                  puts "name is blank"
                                end
                              end

                              def check_phone_number
                                @a = self.phone_number
                                puts "ensure your phone number is #{@a} "
                              end
                          end
          - before_save - triggered before the object is save in the database
                    eg - class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                          end

          - around_save - triggered when the object is being save in the database
                    eg -  class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price
                            around_save :log_activity

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                              def log_activity
                                puts("around save : before save")
                                yield
                                puts("around save : after save")
                              end
                          end
                    practice -  3.3.1 :006 > p = Product.new( id: 4,name: "Mouse",description: "Computer accessory",price: 2000,brand_id: 1,seller_id: 1,category_id: 1)
                                => 
                                #<Product:0x00007fdbc4c7ecd0
                                ... 
                                3.3.1 :007 > p.save
                                  TRANSACTION (0.3ms)  BEGIN
                                  Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Seller Load (0.3ms)  SELECT "sellers".* FROM "sellers" WHERE "sellers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                as the price of the product was not mentioned it was taken as zero by default
                                around save : before save
                                  Product Create (1.0ms)  INSERT INTO "products" ("id", "name", "description", "price", "created_at", "updated_at", "brand_id", "seller_id", "category_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["id", 4], ["name", "Mouse"], ["description", "Computer accessory"], ["price", 2000], ["created_at", "2024-07-03 06:12:13.318960"], ["updated_at", "2024-07-03 06:12:13.318960"], ["brand_id", 1], ["seller_id", 1], ["category_id", 1]]
                                around save : after save
                                the object was successfully saved
                                  Category Update (0.4ms)  UPDATE "categories" SET "updated_at" = $1 WHERE "categories"."id" = $2  [["updated_at", "2024-07-03 06:12:13.322275"], ["id", 1]]
                                  TRANSACTION (3.2ms)  COMMIT
                                => true 
          - before_update - triggered before the object is created in the database
                    eg -  class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            after_commit :commit_info
                            after_rollback :rollback_info

                            before_update :capitalize_title
                            around_update :lifecycle_info_update
                            after_update :updation_info

                            private
                              def capitalize_title
                                title.capitalize! if title.present?
                              end
                              def commit_info
                                puts("The transaction was successfully committed for PaymentType #{self.title}")
                              end
                              def rollback_info
                                puts("The transaction was rolled back because of : #{self.error.full_messages.join(',')}")
                              end
                              def lifecycle_info_update
                                  puts("around update : before update")
                                  yield
                                  puts("around update : after update")
                              end
                              def updation_info
                                puts("The object with id:#{self.id} was successfully updated")
                              end
                          end
                    practice -  3.3.1 :001 > a = PaymentType.last
                                  PaymentType Load (0.4ms)  SELECT "payment_types".* FROM "payment_types" ORDER BY "payment_types"."id" DESC LIMIT $1  [["LIMIT", 1]]
                                => 
                                #<PaymentType:0x00007f1f0ada35b0
                                ... 
                                3.3.1 :002 > a.update(description:"allows to pay in monthly installments")
                                around update : before update
                                  TRANSACTION (0.3ms)  BEGIN
                                  PaymentType Update (1.2ms)  UPDATE "payment_types" SET "description" = $1, "updated_at" = $2 WHERE "payment_types"."id" = $3  [["description", "allows to pay in monthly installments"], ["updated_at", "2024-07-03 06:55:35.873890"], ["id", 10]]
                                around update : after update
                                The object with id:10 was successfully updated
                                  TRANSACTION (2.3ms)  COMMIT
                                The transaction was successfully committed for PaymentType Emi
                                => true 

          - around_update - triggered when the object is being created in the database
                    eg -  class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            after_commit :commit_info
                            after_rollback :rollback_info

                            before_update :capitalize_title
                            around_update :lifecycle_info_update
                            after_update :updation_info

                            private
                              def capitalize_title
                                title.capitalize! if title.present?
                              end
                              def commit_info
                                puts("The transaction was successfully committed for PaymentType #{self.title}")
                              end
                              def rollback_info
                                puts("The transaction was rolled back because of : #{self.error.full_messages.join(',')}")
                              end
                              def lifecycle_info_update
                                  puts("around update : before update")
                                  yield
                                  puts("around update : after update")
                              end
                              def updation_info
                                puts("The object with id:#{self.id} was successfully updated")
                              end
                          end
                    practice -  3.3.1 :001 > a = PaymentType.last
                                  PaymentType Load (0.4ms)  SELECT "payment_types".* FROM "payment_types" ORDER BY "payment_types"."id" DESC LIMIT $1  [["LIMIT", 1]]
                                => 
                                #<PaymentType:0x00007f1f0ada35b0
                                ... 
                                3.3.1 :002 > a.update(description:"allows to pay in monthly installments")
                                around update : before update
                                  TRANSACTION (0.3ms)  BEGIN
                                  PaymentType Update (1.2ms)  UPDATE "payment_types" SET "description" = $1, "updated_at" = $2 WHERE "payment_types"."id" = $3  [["description", "allows to pay in monthly installments"], ["updated_at", "2024-07-03 06:55:35.873890"], ["id", 10]]
                                around update : after update
                                The object with id:10 was successfully updated
                                  TRANSACTION (2.3ms)  COMMIT
                                The transaction was successfully committed for PaymentType Emi
                                => true        

          - after_update - triggered after the object is created in the database
                    eg -  class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            after_commit :commit_info
                            after_rollback :rollback_info

                            before_update :capitalize_title
                            around_update :lifecycle_info_update
                            after_update :updation_info

                            private
                              def capitalize_title
                                title.capitalize! if title.present?
                              end
                              def commit_info
                                puts("The transaction was successfully committed for PaymentType #{self.title}")
                              end
                              def rollback_info
                                puts("The transaction was rolled back because of : #{self.error.full_messages.join(',')}")
                              end
                              def lifecycle_info_update
                                  puts("around update : before update")
                                  yield
                                  puts("around update : after update")
                              end
                              def updation_info
                                puts("The object with id:#{self.id} was successfully updated")
                              end
                          end
                    practice -  3.3.1 :001 > a = PaymentType.last
                                  PaymentType Load (0.4ms)  SELECT "payment_types".* FROM "payment_types" ORDER BY "payment_types"."id" DESC LIMIT $1  [["LIMIT", 1]]
                                => 
                                #<PaymentType:0x00007f1f0ada35b0
                                ... 
                                3.3.1 :002 > a.update(description:"allows to pay in monthly installments")
                                around update : before update
                                  TRANSACTION (0.3ms)  BEGIN
                                  PaymentType Update (1.2ms)  UPDATE "payment_types" SET "description" = $1, "updated_at" = $2 WHERE "payment_types"."id" = $3  [["description", "allows to pay in monthly installments"], ["updated_at", "2024-07-03 06:55:35.873890"], ["id", 10]]
                                around update : after update
                                The object with id:10 was successfully updated
                                  TRANSACTION (2.3ms)  COMMIT
                                The transaction was successfully committed for PaymentType Emi
                                => true 

          - after_save -  triggered after the object is save in the database
                    eg -  class Product < ApplicationRecord
                            belongs_to :brand , inverse_of: :products, validate: true
                            belongs_to :category, inverse_of: :products, validate: true, touch: true
                            belongs_to :seller, inverse_of: :products, validate: true
                            has_many :reviews
                            has_and_belongs_to_many :orders



                            validates :name, presence: true
                            validates :description, presence: true
                            validates :price, presence: true, numericality: true


                            before_save :set_default_price
                            around_save :log_activity
                            after_save :clear_cache

                            private
                              def set_default_price
                                self.price ||= 0
                                puts("as the price of the product was not mentioned it was taken as zero by default")
                              end
                              def log_activity
                                puts("around save : before save")
                                yield
                                puts("around save : after save")
                              end
                              def clear_cache
                                CacheService.clear_product_cache(self)
                              end
                          end
                    practice -  3.3.1 :006 > p = Product.new( id: 4,name: "Mouse",description: "Computer accessory",price: 2000,brand_id: 1,seller_id: 1,category_id: 1)
                                => 
                                #<Product:0x00007fdbc4c7ecd0
                                ... 
                                3.3.1 :007 > p.save
                                  TRANSACTION (0.3ms)  BEGIN
                                  Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  Seller Load (0.3ms)  SELECT "sellers".* FROM "sellers" WHERE "sellers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                as the price of the product was not mentioned it was taken as zero by default
                                around save : before save
                                  Product Create (1.0ms)  INSERT INTO "products" ("id", "name", "description", "price", "created_at", "updated_at", "brand_id", "seller_id", "category_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING "id"  [["id", 4], ["name", "Mouse"], ["description", "Computer accessory"], ["price", 2000], ["created_at", "2024-07-03 06:12:13.318960"], ["updated_at", "2024-07-03 06:12:13.318960"], ["brand_id", 1], ["seller_id", 1], ["category_id", 1]]
                                around save : after save
                                the object was successfully saved
                                  Category Update (0.4ms)  UPDATE "categories" SET "updated_at" = $1 WHERE "categories"."id" = $2  [["updated_at", "2024-07-03 06:12:13.322275"], ["id", 1]]
                                  TRANSACTION (3.2ms)  COMMIT
                                => true 
          - after_commit/after_rollback - triggered if the transaction is completed/rollback
                    eg -   class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            after_commit :commit_info
                            after_rollback :rollback_info

                            private
                              
                              def commit_info
                                puts("The transaction was successfully committed for PaymentType #{self.title}")
                              end
                              def rollback_info
                                puts("The transaction was rolled back because of : #{self.error.full_messages.join(',')}")
                              end
                          end
                    practice -  3.3.1 :016 > a = PaymentType.create(title:"EMI", description:"methodtopay in installments")
                                around create : before create
                                  TRANSACTION (0.2ms)  BEGIN
                                  PaymentType Create (1.1ms)  INSERT INTO "payment_types" ("title", "description", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["title", "Emi"], ["description", "methodtopay in installments"], ["created_at", "2024-07-03 06:45:31.682087"], ["updated_at", "2024-07-03 06:45:31.682087"]]
                                around create : after create
                                Payment type was successfully created
                                  TRANSACTION (1.9ms)  COMMIT
                                The transaction was successfully committed for PaymentType Emi
                                => 
                                #<PaymentType:0x00007ff09a08eac0

    - DESTROYING AN OBJECT - 
          - before_destroy - triggered before the object is created in the database
          - around_destroy - triggered when the object is being created in the database
          - after_destroy - triggered after the object is created in the database
          - after_commit/after_rollback - triggered if the transaction is completed/rollback
                    
                    eg -  class PaymentType < ApplicationRecord
                            has_many :payments, validate: true

                            validates :title, presence: true

                            after_commit :commit_info
                            after_rollback :rollback_info

                            before_destroy :deletion_start
                            around_destroy :destruction_cycle
                            after_destroy :deletion_info
                            private
                              def commit_info
                                puts("The transaction was successfully committed for PaymentType #{self.title}")
                              end
                              def rollback_info
                                puts("The transaction was rolled back because of : #{self.error.full_messages.join(',')}")
                              end
                              def deletion_start
                                puts("deletion is specified for #{self.title} PaymentType ")
                              end
                              def destruction_cycle
                                  puts("around deletion : before deletion the the object")
                                  yield
                                  puts("around deletion : after deletion the the object")
                              end
                              def deletion_info
                                puts("the object specified was successfully deleted from the database")
                              end
                          end

                    practice -  3.3.1 :001 > PaymentType.last.destroy
                                  PaymentType Load (0.4ms)  SELECT "payment_types".* FROM "payment_types" ORDER BY "payment_types"."id" DESC LIMIT $1  [["LIMIT", 1]]
                                deletion is specified for Emi PaymentType 
                                around deletion : before deletion the the object
                                  TRANSACTION (0.2ms)  BEGIN
                                  PaymentType Destroy (1.4ms)  DELETE FROM "payment_types" WHERE "payment_types"."id" = $1  [["id", 10]]
                                around deletion : after deletion the the object
                                the object specified was successfully deleted from the database
                                  TRANSACTION (1.2ms)  COMMIT
                                The transaction was successfully committed for PaymentType Emi
                                => 
                                #<PaymentType:0x00007f2c1562ce40
                                id: 10,
                                title: "Emi",
                                description: "allows to pay in monthly installments",
                                created_at: Wed, 03 Jul 2024 06:45:31.682087000 UTC +00:00,
                                updated_at: Wed, 03 Jul 2024 06:55:35.873890000 UTC +00:00> 


    Note - 
          1. if exception occurs in an after_save, transaction will be rolled back and the data will not be persisted in the database
          2. execution of after_commit ensures that the transaction has already completed and data has persisted to database


    OTHER CALLBACKS - 
          - after_initialize - triggered after an object is initialized
                             - can be called directly using new or when a record is loaded from the database
                             - useful for avoiding the need to directly override the ActiveRecord initialize method, because it allows you to add initialization logic without affecting the core initialization process of ActiveRecord
                             - has no other counter parts like before, around, etc.
                      eg -  class Brand < ApplicationRecord
                              has_many :products, dependent: :destroy

                              validates :title, presence: true

                              after_initialize :log_initialize

                              private
                                def log_initialize
                                  puts("you have initialized an new object")
                                end
                            end
                      practice -  3.3.1 :001 > b = Brand.new
                                  you have initialized an new object
                                  => #<Brand:0x00007f250895b0a8 id: nil, title: nil, description: nil, created_at: nil, updated_at: nil> 

          - after_find - triggered after loading an object from database
                       - called before initialize if both are mentioned
                       - has no counter parts like before, around, etc.
                      eg -  class Brand < ApplicationRecord
                              has_many :products, dependent: :destroy

                              validates :title, presence: true

                              after_find :log_found

                              private
                                def log_found
                                  puts("you have found a new object with id: #{self.id}")
                                end
                            end
                      practice -  3.3.1 :002 > Brand.find(1)
                                    Brand Load (0.4ms)  SELECT "brands".* FROM "brands" WHERE "brands"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
                                  you have found a new object with id: 1
                                  you have initialized an new object
                                  => 
                                  #<Brand:0x00007f25080d9880
                                  id: 1,
                                  title: "puma",
                                  description: "logo of cheetah",
                                  created_at: Fri, 10 May 2024 04:50:16.699633000 UTC +00:00,
                                  updated_at: Fri, 10 May 2024 04:50:16.699633000 UTC +00:00> 

          - after_touch - called after an object has been touched 
                        - can be used along with belongs_to
                      eg -  class Brand < ApplicationRecord
                              has_many :products, dependent: :destroy

                              validates :title, presence: true

                              after_touch :log_touched

                              private
                                def log_touched
                                  puts("you have touched the object with id: #{self.id}")
                                end
                            end
                      practice -  3.3.1 :004 > b.touch
                                    TRANSACTION (0.3ms)  BEGIN
                                    Brand Update (1.2ms)  UPDATE "brands" SET "updated_at" = $1 WHERE "brands"."id" = $2  [["updated_at", "2024-07-03 07:26:47.357580"], ["id", 1]]
                                  you have touched the object with id: 1
                                    TRANSACTION (1.8ms)  COMMIT
                                  => true 

RUNNING CALLBACKS - querying methods that trigger callback
    Basic - methods that trigger all kind of callbacks
          1.create  - creates a new object and saves it to database, returns where object passes validations or not
          2.create! - does same but raises error if validations not passed
          3.destroy - deletes object from database, tells where object was successfully deleted or not
          4.destroy! - does same but raises error if the object was not deleted successfully
          5.destroy_all - deletes all the objects that match the condition and returns the affected objects
          6.destroy_by - deletes the objects that match the condition and returns the affected objects
          7.save - saves the object or changes made to it to the database , return if the object was successfully saved or not
          8.save! - does same but raises error when object not saved successfully
          9.save(validate: false) - same as "save" but turns the validations of
          10.save!(validate: false) - same as "save!" but turns the validations of
          11.toggle! - counter-switches the value of a boolean attribute and saves it to database directly [turns false to true and wise versa]
          12.touch - updates the updated_at/updated_on timestamp of the object
          13.update_attribute - used to update and save a specific attribute of the object, returns if update was successful or not
          14.update - used to update and save a specific as well as multiple attributes of the object, returns if update was successful or not 
          15.update! - does same but raises error if updation was unsuccessful
          16.valid - checks if the object is valid or not 

    Additional for after_find - 
          1.all - retrieves and displays all the records of a table
          2.first - retrieves and displays the first records of a table
          3.find - finds and displays a record with the particular id mentioned
          4.find_by_* - finds and displays a record by particular attribute
          5.find_by_*! - same but raises error if object not found
          6.find_by_sql - finds and displays a record based on the sql statement specified
          7.last - retrieves and displays the last records of a table

    after_initialize - triggered every time a new object of a class is initialized

SKIPPING CALLBACKS - refers to methods that never trigger callback methods
                   - these methods don't instantiate a model and hence callbacks are not triggered
                   
          1.decrement! - decreases the value of specified attribute by 1, saves the record 
          2.decrement_counter - automatically decreases the value of the specified counter by 1 in the database
          3.delete - remove record from database by its  primary key 
          4.delete_all - deletes all records matching the condition 
          5.increment! - increases the value specified attribute by 1 and saves the record
          6.increment_counter - automatically increases the value of specified counter by 1 in the database  
          7.insert - used to add new record into the database and returns primary key of the newly inserted object 
          8.insert! - similar to above but raises exception if the insert fails  
          9.insert_all -inserts multiple records into the database in a single query  
          10.insert_all! - does same but raises error if exception occurs 
          11.touch_all - updates the updated_at timestamp of all the records matching the condition 
          12.update_column - updates a single attribute in the database 
          13.update_columns - updates multiple attributes in the database
          14.update_all - updates the attributes of all the records matching the condition
          15.update_counters - automatically updates the counters of the specified attribute for all the records matching the conditions
          16.upsert - insert a record if it doesn't exists or updates if it does 
          17.upsert_all - inserts multiple records if they don't exists and updates them if they do exist
          18.delete_by - deletes records that match certain condition





